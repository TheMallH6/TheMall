@page "/create"

@using System.Text.Json
@using TheMall.Data.CanvasData
@using System.Drawing
@using Blazor.Extensions
@using Blazor.Extensions.Canvas;
@using Blazor.Extensions.Canvas.Canvas2D;
@using Blazor.Extensions.Canvas.WebGL;
@using BlazorColorPicker
@using System.Collections.Generic;
@using TheMall.Data;
@using Newtonsoft.Json;
@using Newtonsoft.Json.Linq;
@using TheMall.Data.Modles;

@inject AppState AppState
@inject ISessionManager sManager;

<h3>Map over:  @UName</h3>

<div style="display: inline-block;">
    <div id="drawCanvas" class="canvasStyle" tabindex="0" @onmousedown="MouseDown" @onmouseup="MouseUp" style="float: left;">
        <BECanvas Width="600" Height="500" @ref="canvasRef" />
    </div>

    <div style="float: right; width: 300px; margin-left: 30px;">
        <h3>Skitse plantegning.</h3>
        <div>
            <button class="drawBTN drawBTNsizeL" @onclick="DrawMap" style="align-content:center">Tegn dit kort</button>
        </div>
        <div>
            <select @bind="mapLayer" class="mall-selector">
                @foreach (var map in maps)
                {
                    <option value="@map.layer">@map.layer</option>
                }
            </select>
        </div>
        <div>
            <button class="drawBTN drawBTNsizeL" @onclick="() => ToolChanger(DrawTool.polygon)" style="align-content:center">Tegn en figur</button>
        </div>
        <div>
            <button class="drawBTN drawBTNsizeL" @onclick="() => ToolChanger(DrawTool.square)" style="align-content:center">Tegn en firkant</button>
        </div>
        <div>
            <button class="drawBTN drawBTNsizeL" @onclick="() => ToolChanger(DrawTool.line)" style="align-content:center">Tegn en streg</button>
        </div>
        <div>
            <button class="drawBTN drawBTNsizeS" @onclick="UndoLast" style="align-content:center">Fortryd</button>
        </div>
        <input id="fillBox" type="checkbox" @bind-value="@fill" />
        <label for="fillBox"> Anvend farve</label>
        <br />

        <button class="drawBTN drawBTNsizeL" @onclick="OnColorPickerOpen">
            <div style="background-color:@baseColorPicker" class="buttonColor"></div> Vælg farve
        </button>

        <ColorPicker Title="Stop and go ColorPicker" IsOpened="isOpened" Closed="OnColorPickerClosed" MyColor="@baseColorPicker"></ColorPicker>
        <br />
        <hr />
        <h3>Insæt lokation.</h3>
        @*        <div>
        <button class="drawBTN drawBTNsizeL">Upload ikon</button>
        </div>*@
        @*        <div>
        <button class="drawBTN drawBTNsizeL" @onclick="">Skriv Tekst</button>
        </div>*@
        <EditForm Model="layer">
            <div class="form-group">
                <label for="name">
                    Etage:
                    <InputNumber Id="layer" Class="form-control formLay" @bind-Value="@layer"></InputNumber>
                </label>
            </div>
        </EditForm>
        <button class="drawBTN drawBTNsizeL" @onclick="Save" style="align-content:center; margin-top: 4%;">Opret</button>
    </div>
</div>

@code {
    private int clicks = 0;
    private Point pointOnEnter;
    private Point pointOnExit;
    private BECanvasComponent? canvasRef;
    private List<ComponentV> Components { get; set; } = new List<ComponentV>();
    private List<int> Xinput { get; set; } = new List<int>();
    private List<int> Yinput { get; set; } = new List<int>();
    private List<Map> maps { get; set; } = new List<Map>();
    private Canvas2DContext ctx;
    private RestCaller restCaller { get; set; } = new RestCaller();
    private DrawTool selectedTool = DrawTool.polygon;
    bool isOpened = false;
    bool isHidden = true;
    string baseStrokeColor = "#777";
    string baseColorPicker = "#D12B27";
    private bool fill;
    private int layer;
    private int mapLayer;

    public string UName { get; set; }
    public string URole { get; set; }
    
    /* protected override void OnInitialized()
    {
    UName = AppState.FuName.UserName;
    URole = AppState.FuRole.Role;
    if (URole == "Redaktør")
    {
    isHidden = false;
    }
    else
    {
    isHidden = true;
    }
    } */

    protected override void OnInitialized()
    {
        sManager.OnChange += UpdateMapList;
    }

    private async void UpdateMapList()
    {
        maps = await restCaller.GetMap(sManager.GetKey("MallID"));
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this.ctx = await canvasRef.CreateCanvas2DAsync();
    }

    protected void ToolChanger(DrawTool tool)
    {
        clicks = 0;
        SaveGeoDataOnTooChange();
        selectedTool = tool;

    }

    private async void MouseDown(MouseEventArgs args)
    {
        clicks++;
        pointOnEnter = new Point((int)args.OffsetX, (int)args.OffsetY);
    }

    private async void MouseUp(MouseEventArgs args)
    {
        pointOnExit = new Point((int)args.OffsetX, (int)args.OffsetY);

        DrawingObjectByTool();
    }

    private async void DrawingObjectByTool()
    {
        await ctx.BeginBatchAsync();

        if (fill)
            await ctx.SetFillStyleAsync(baseColorPicker);

        switch (selectedTool)
        {
            case DrawTool.polygon:

                if (clicks == 1)
                {
                    await ctx.MoveToAsync(pointOnEnter.X, pointOnEnter.Y);
                    Xinput.Add(pointOnEnter.X);
                    Yinput.Add(pointOnEnter.Y);
                }
                else
                {
                    await ctx.LineToAsync(pointOnExit.X, pointOnExit.Y);
                    Xinput.Add(pointOnEnter.X);
                    Yinput.Add(pointOnEnter.Y);

                    if (fill)
                    {
                        await ctx.FillAsync();
                        await ctx.SetStrokeStyleAsync(baseColorPicker);
                    }
                    else
                    {
                        await ctx.SetStrokeStyleAsync(baseStrokeColor);
                    }
                }
                await ctx.StrokeAsync();


                break;

            case DrawTool.line:

                await ctx.MoveToAsync(pointOnEnter.X, pointOnEnter.Y);
                await ctx.LineToAsync(pointOnExit.X, pointOnExit.Y);
                Xinput.Add(pointOnEnter.X);
                Yinput.Add(pointOnEnter.Y);
                Xinput.Add(pointOnExit.X);
                Yinput.Add(pointOnExit.Y);
                SaveGeoDataOnTooChange();
                await ctx.StrokeAsync();
                await ctx.RestoreAsync();

                if (fill)
                {
                    await ctx.SetStrokeStyleAsync(baseColorPicker);
                }
                else
                {
                    await ctx.SetStrokeStyleAsync(baseStrokeColor);
                }

                break;

            case DrawTool.square:
                var rect = new RectangleF(
                           Math.Min(pointOnEnter.X, pointOnExit.X),
                           Math.Min(pointOnEnter.Y, pointOnExit.Y),
                           Math.Abs(pointOnEnter.X - pointOnExit.X),
                           Math.Abs(pointOnEnter.Y - pointOnExit.Y));

                InsertCordsSquar(rect);
                if (fill)
                {

                    await ctx.StrokeRectAsync(rect.X, rect.Y, rect.Width, rect.Height);
                    await ctx.FillRectAsync(rect.X, rect.Y, rect.Width, rect.Height);
                    await ctx.SetStrokeStyleAsync(baseColorPicker);

                }
                else
                {
                    await ctx.StrokeRectAsync(rect.X, rect.Y, rect.Width, rect.Height);
                    await ctx.SetStrokeStyleAsync(baseStrokeColor);
                }

                break;
        }
        await ctx.EndBatchAsync();
    }

    private async void DrawMap()
    {
        Components.Clear();
        bool firstDraw = true;
        for (int i = 0; i < maps.Count; i++)
        {
            if (mapLayer == maps[i].layer)
            {
                MapDictionaryOfComps(maps[i]);
                for (int j = 0; j < Components.Count; j++)
                {
                    await ctx.BeginBatchAsync();
                    for (int x = 0; x < Components[j].Geodata.XInput.Length; x++)
                    {
                        if (firstDraw == true)
                        {
                            await ctx.MoveToAsync(Components[j].Geodata.XInput[x], Components[j].Geodata.YInput[x]);
                            firstDraw = false;
                        }
                        else
                            await ctx.LineToAsync(Components[j].Geodata.XInput[x], Components[j].Geodata.YInput[x]);
                    }
                    await ctx.EndBatchAsync();
                    firstDraw = true;
                }
            }
            await ctx.StrokeAsync();
            await ctx.SetStrokeStyleAsync(baseStrokeColor);
        }

    }

    private void MapDictionaryOfComps(Map map)
    {
        Components.Clear();
        foreach (var item in map.components)
        {
            var geodata = item.Value.ToString();
            var options = new JsonSerializerSettings()
                {
                    DefaultValueHandling = DefaultValueHandling.Ignore,
                    NullValueHandling = NullValueHandling.Ignore,
                };
            var components = JsonConvert.DeserializeObject<IEnumerable<ComponentV>>(geodata, options);
            foreach (var item2 in components)
            {
                Components.Add(new ComponentV(item2.Description, item2.ZIndex, item2.Geodata));
            }
        }
    }

    private void SaveGeoDataOnTooChange()
    {


        if (Xinput.Count <= 0 || Yinput.Count <= 0)
        {

        }
        else
        {
            Components.Add(new ComponentV("", 0, new GeodataV(GetTypeOfComponentBYTool(), Xinput.ToArray(), Yinput.ToArray(), 4321)));
            ClearXandYArrays();
        }

    }

    private void InsertCordsSquar(RectangleF rect)
    {
        Xinput.Add((int)rect.X);
        Yinput.Add((int)rect.Y);
        Xinput.Add((int)rect.X);
        Yinput.Add((int)rect.Y + (int)rect.Height);
        Xinput.Add((int)rect.X + (int)rect.Width);
        Yinput.Add((int)rect.Y + (int)rect.Height);
        Xinput.Add((int)rect.X + (int)rect.Width);
        Yinput.Add((int)rect.Y);
        Xinput.Add((int)rect.X);
        Yinput.Add((int)rect.Y);
        SaveGeoDataOnTooChange();
    }

    private string GetTypeOfComponentBYTool()
    {
        string type = "";
        switch (selectedTool)
        {
            case DrawTool.line:
                type = "LINE";
                break;
            case DrawTool.polygon:
                Xinput.Add(Xinput[0]);
                Yinput.Add(Yinput[0]);
                type = "POLYGON";
                break;
            case DrawTool.square:
                type = "POLYGON";
                break;
        }
        return type;
    }

    private void ClearXandYArrays()
    {
        Xinput.Clear();
        Yinput.Clear();
    }

    private void OnColorPickerOpen()
    {
        isOpened = true;
    }

    private void OnColorPickerClosed(string value)
    {
        baseColorPicker = value;
        isOpened = false;
    }

    private async void UndoLast()
    {
        ctx.ClearRectAsync(0, 0, (double)canvasRef.Width, (double)canvasRef.Height);
        //allObjInList.RemoveAt(allObjInList.Count - 1);
    }
    private MapV CreateMap()
    {
        MapV map = new MapV(sManager.GetKey("MallID"), layer, Components);
        return map;
    }

    protected async void Save()
    {
        await restCaller.InsertMap(CreateMap());
        Components.Clear();
    }
}
